<p id="b9ce078d-d49e-45c9-81dd-735d07a65bb5" class="">Monitor, mutex, and semaphores can be confusing concepts initially.</p><p id="478c5acf-81e3-4a8f-8aa2-6c9d85d0edb8" class="">A monitor is made up of a mutex and a condition variable.</p><p id="de037e60-a26f-45f7-b257-8ba2135726b4" class="">One can think of a mutex as a subset of a monitor.</p><p id="b123e3e6-48be-4e67-bdbb-50461e46b784" class="">
</p><p id="72ac41c4-5c0b-4033-8daa-c477f9e5ef55" class=""><strong>Differences between a monitor and a semaphore:</strong></p><ul id="e16c539e-b0d5-4413-bcf9-5028c7ccbf1f" class="bulleted-list"><li>A monitor and a semaphore are interchangeable.<p id="6f5bd787-2f2f-4efc-8379-667da22fdd87" class="">Theoretically, one can be constructed out of the other or one can be reduced to the other.</p><p id="6ba5e3b5-ca0c-4e8c-a404-a158ebdb205e" class="">However, monitors take care of atomically acquiring the necessary locks whereas, with semaphores, the onus of appropriately acquiring and releasing locks is on the developer, which can be error-prone.</p></li></ul><ul id="b41859fb-c3ea-4afc-9a2e-b3a0fe445a95" class="bulleted-list"><li>Semaphores are lightweight when compared to monitors, which are bloated.<p id="5ab536af-7ab2-48a8-ad09-4d464c528765" class="">However, the tendency to misuse semaphores is far greater than monitors.</p><p id="10c8ba37-ce06-4dc6-a7f4-b592547a6873" class="">When using a semaphore and mutex pair as an alternative to a monitor, it is easy to lock the wrong mutex or just forget to lock altogether.</p><p id="a45e964f-95b5-46de-8691-338265e6e70e" class="">Even though both constructs can be used to solve the same problem, monitors provide a pre-packaged solution with less dependency on a developer&#x27;s skill to get the locking right.</p></li></ul><ul id="95a632ea-071c-4db5-ac0c-307f009188aa" class="bulleted-list"><li>In Python the class <strong>Condition</strong> is the implementation of the monitor concept.<p id="2b142341-7c7a-4ced-8d3a-c50b641a7406" class="">Condition variables enforce correct locking by raising an exception when a thread attempts to invoke the <strong>wait()</strong> or <strong>notify()</strong> methods without acquiring the lock associated with the condition variable.</p></li></ul><ul id="9474dad6-792a-4eda-b3d4-69039a7f62d6" class="bulleted-list"><li>A semaphore can allow several threads access to a given resource or critical section.<p id="986b8976-c57b-4528-a451-211d1ad91be5" class="">However, only a single thread can <strong>own</strong> the monitor and access associated resource at any point.</p></li></ul><ul id="72f6ef34-2e15-40e8-95cf-98ea7f57c56f" class="bulleted-list"><li>Semaphores can be used to address the issue of <strong>missed signals.</strong><p id="1d6fb2c3-f3e8-4ff5-83c1-bdc2deb1767d" class="">However, with monitors, the additional state, called the predicate, needs to be maintained apart from the condition variable and the mutex, which make up the monitor, to solve the issue of missed signals.</p></li></ul><p id="f95bda85-1e70-44a7-82e4-90921f6aa122" class="">
</p><p id="951b1c33-35a1-4fb6-94e4-c63e2d7fd6b7" class="">
</p>