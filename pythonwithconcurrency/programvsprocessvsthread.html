<ul id="21fb5386-91f7-498a-be57-c1007f70f900" class="bulleted-list"><li>Program<p id="413d53d0-a26a-4597-95c7-313650c9d44d" class="">A program is a set of instructions and associated data that resides on the disk and is loaded by the operating system to perform a task.</p><p id="5a78839e-749a-4c02-ac29-e75fa1bd7bde" class="">An executable file or a python script file are examples of programs.</p></li></ul><ul id="94cc243f-b33c-424c-90ca-1eda126aeb62" class="bulleted-list"><li>Process<p id="9af59613-1660-4e28-b6cf-676ce39ca648" class="">A process is a program in execution.</p><p id="aea91c12-b97a-4c7c-9af2-c8c6fc9e937a" class="">A process is an execution environment that consists of instructions, user-data, and system-data segments, as well as lots of other resources such as CPU, memory, address-space, disk and network I/O acquired at runtime.</p><p id="5d36a4cd-966a-47ea-b53a-add544c99d18" class="">A program can have several copies of it running at the same time but a process necessarily belongs to only one program.</p></li></ul><ul id="e7ad5bbd-4d88-4513-b7b0-6e32f489e8f5" class="bulleted-list"><li>Thread<p id="c5c57977-6fe0-4943-86ca-c673374260b5" class="">A thread is the smallest unit of execution in a process which simply executes instructions serially.</p><p id="0252b54b-526d-4ba7-a139-50d5a3476909" class="">A process can have multiple threads running as part of it.</p><p id="45e0cfc6-7509-4143-be97-cf3631c6a0d5" class="">Usually, there would be some state associated with the process that is shared among all the threads and in turn each thread would have some state private to itself.</p><p id="6015184f-52e9-4d16-b3de-c05b50d71fb1" class="">The globally shared state amongst the threads of a process is visible and accessible to all the threads, and special attention needs to be paid when any thread tries to read or write to this global shared state.</p></li></ul><p id="933f8fd1-f5fd-4fc8-8c8b-5e2829119b72" class="">
</p><p id="2bb297de-e7b2-4bff-b665-92ba2a52ed51" class=""><strong>Notes</strong></p><ul id="3b41f7dc-009c-4719-9ea3-13cca7aade94" class="bulleted-list"><li>&quot;program&quot; and a &quot;process&quot; are often used interchangeably, though most of the time the intent is to refer to a process.</li></ul><ul id="d0375233-2e97-4bb1-ac92-2d7672e10a06" class="bulleted-list"><li>There&#x27;s also the concept of &quot;multiprocessing&quot; systems, where multiple processes get scheduled on more than one CPU. Usually, this requires hardware support, where a single system comes with multiple cores or the execution takes place in a cluster of machines.</li></ul><ul id="5c724e29-9a64-499e-92ff-da4acaf2df1d" class="bulleted-list"><li>Processes don&#x27;t share any resources amongst themselves whereas threads of a process can share the resources allocated to that particular process, including memory address space.</li></ul><p id="000a798f-c233-4be8-ba01-c4313a808a24" class="">
</p>
<div class="text-center">
    <img src="assets_env_image/1.png" class="rounded" alt="..." style="width: 80%;">
</div>
<p id="933fc4a4-23f2-42d6-85b9-be08f1f44149" class="">
</p><h2 id="c69892d4-2dcd-43d5-ada4-48b0032f65fc" class="">Counter Program</h2><p id="b6785999-0517-4663-a3ef-720429775f0f" class="">Incorrect synchronization between threads can lead to wildly varying program  outputs depending on the order in which threads get executed.</p><p id="68e0b922-c763-4c0b-933e-fa0ae1d15fd6" class="">Consider the snippet of code below:</p>
<div class="code-wrapper">
<pre id="d381d9ac-f9ca-41dd-a1c0-c4bc93b530c0" class="code"><code id="code">1. counter = 0
2.
3. def increment_counter():
4.     counter += 1</code></pre>
<p id="18176058-ecf7-455a-912a-f634aa2eba96" class="">The increment on <strong>line 4</strong> is likely to be decompiled into the following steps on a computer:</p><ul id="8d798b98-83f1-40c1-922e-4e3d6e6e3415" class="bulleted-list"><li>Read the value of the variable counter from the register where it is stored.</li></ul><ul id="01044934-daa4-4e39-8aca-f1cd3e68a096" class="bulleted-list"><li>Add one to the value just read.</li></ul><ul id="bdf127fb-ecb6-4668-945f-aa41d90566e1" class="bulleted-list"><li>Store the newly computed value back to the register.</li></ul><p id="61587c8b-acea-42db-a0f5-d9e4bfefefc7" class="">The innocuous looking statement on <strong>line 4</strong> is really a three-step process!</p><p id="f823b70a-0f11-4cc7-a600-edbdda951219" class="">Now imagine if we have two threads trying to execute the same function <code>increment_counter()</code>. One of the ways the execution of the two threads can take place is as follows:</p><p id="cc2e175e-d9d5-44ec-922b-ef088391c662" class="">Let&#x27;s call one thread as <strong>T1</strong> and the other as <strong>T2</strong>. Say the counter value is equal to 7.</p><p id="58dda266-6d9a-466c-b72a-8fa138ad5765" class="">
</p><ol id="11375d1c-df11-4004-b875-51b94cfc5598" class="numbered-list" start="1"><li><strong>T1</strong> is currently scheduled on the CPU and enters the function. It performs step A, i.e. reads the value of the variable from the register, which is 7.</li></ol><ol id="057e730b-c9ff-4818-a3e1-3cd1cce9319f" class="numbered-list" start="2"><li>The operating system decides to context switch <strong>T1</strong> and bring in <strong>T2</strong>.</li></ol><ol id="a2ae37f0-0abc-4f75-b802-3c52340471d3" class="numbered-list" start="3"><li><strong>T2</strong> gets scheduled and luckily gets to complete all the three steps <strong>A</strong>, <strong>B</strong> and <strong>C</strong>, before getting switched out for <strong>T1</strong>. It reads the value 7, adds one to it and stores 8 back.</li></ol><ol id="3ade33d8-95bd-4f9b-89ff-bf9d0bbe3c96" class="numbered-list" start="4"><li><strong>T1</strong> comes back, and since its state was saved by the operating system, it still has the stale value of 7 that it read before being context-switched.<p id="957f3895-cfd2-4393-b42a-2885c76b3b26" class="">It doesn&#x27;t know that the value of the variable has been updated behind its back and, unfortunately, thinking the value is still 7, adds one to it and overwrites the existing 8 with its own computed 8.</p><p id="b3491533-6a67-4256-be4f-149def73831c" class="">If the threads executed serially the final value would have been 9.</p></li></ol><p id="2a365bc6-5e28-4483-9f09-d2b13b714d6d" class="">
</p><p id="1f3f1965-3d9c-4877-810f-8a98168f353c" class="">Without properly guarding access to mutable variables or data-structures, threads can cause hard-to-find to bugs.</p><p id="269d1475-bd68-4dfc-8dff-41f1a3de2294" class="">Since the execution of the threads can&#x27;t be predicted and is entirely up to the operating system, we can&#x27;t make any assumptions about the order in which threads get scheduled and executed.</p><p id="f7de9212-5c51-40a8-b8f2-cd117b2a99ca" class="">
</p>