<p id="502f180e-0ee6-4c7c-a8cc-10037098c9ae" class="">A quick refresher of how Python works is necessary to understand the acronym GIL or global interpreter lock.</p><p id="243d4073-d12f-4585-b138-8c23cc22395e" class="">
</p><p id="d61f3532-326f-4a55-b736-1de5158a4dba" class=""><strong>How Python works</strong></p><p id="17feaa43-5161-4bad-9853-e34a4dc4fd5d" class="">Python is an interpreted language, that is, there is no static time compiling as that happens in the case of Java, C or C++.</p><p id="574df369-dab4-41f1-8fa2-915f3f2be5ff" class="">The program that interprets user code is called the Interpreter.</p><p id="8bc0b4c1-b905-4694-9a4c-f16bc5f78a17" class="">An interpreter is a program that executes other programs.</p><p id="eaa0d551-d905-43e0-bda2-a1a53a32febe" class="">At a higher level when we run a Python program (.py file), the Python interpreter compiles the source code into byte code.</p><p id="e63cde37-0f8b-4853-ab2d-3b3ae5583137" class="">The generated byte code is a lower-level platform-independent representation that can be understood by the Python Virtual Machine (PVM).</p><p id="12f8911e-7d27-40ed-981b-4ce8a15b1bd1" class="">In the next step, the byte code is routed to the PVM for execution.</p><p id="75250dd1-4683-40cd-adfc-ced0b8e40bd4" class="">Note that PVM isn&#x27;t a separate component.</p><p id="76eaeefb-a383-4eb4-ab88-e03ca905af58" class="">Rather, it is just a loop in the Python interpreter that is responsible for executing byte code line by line.</p><p id="500eb629-c0b5-4dd3-8e95-3b38aa4d2d42" class="">The PVM is really a part of the interpreter.</p><p id="cb1a6fa7-2de1-4aeb-87d1-6fc8819ac6be" class="">
</p><p id="48434db3-c1ed-4de3-b727-2f36bcf61e21" class=""><strong>Python Interpreter</strong></p><p id="0fae3b25-4c31-4f71-b94a-1d456c1e17a7" class="">The Python interpreter as explained is responsible for executing a program, but it can only execute a single thread at a time.</p><p id="62ca560f-e6cf-45a4-a0f5-d5a10577cbb8" class="">This is the falling of the reference implementation of Python - CPython, called so because it is written in the C language.</p><p id="f0a53b5c-e127-4bf7-80a3-450e4bb84158" class="">So if your machine has one, ten, or a hundred processors, the Python interpreter is only able to run a single thread at a time using a single processor.</p><p id="6c0b930a-0531-41d7-9153-5d6cd65934ba" class="">Two threads on a machine with two available processors can&#x27;t be executed in parallel each running on a single CPU.</p><p id="7079cd5e-6226-4b0b-82ad-0e91c508f39c" class="">
</p>
<br>
<p id="dc14bb59-4f35-4491-a482-02518e5a8e5d" class="">This design has direct consequences on the performance of CPU bound programs since they don&#x27;t experience any speed-up in the presence of additional processors.</p><p id="4b6d3434-87fc-46a5-bf9f-d3e985d1b1f6" class="">In fact, they may run slower because of the additional housekeeping overhead required for running multiple threads.</p><p id="ccb28988-8e02-4196-9b91-7668ac71efa5" class="">
</p>
<br>
<p id="bf5aeb10-f15b-4556-8553-9c3bc9475385" class=""><strong>Why is that so?</strong></p><p id="5562e2e4-3058-4e18-a3b9-5605439268b4" class="">One may wonder what was the design decision behind restricting the interpreter to run a single thread.</p><p id="5e2e1638-f83d-4c57-bb54-664d98f8a66e" class="">The answer lies in how memory management works in Python - reference counter.</p><p id="af46a77b-c4a1-41db-b200-dabd1a7d0367" class="">
</p>
<div class="code-wrapper">
<pre id="c28d071e-1537-40d0-9ed8-45a00579e63a" class="code"><code id="code">import sys

# declare a variable
some_var = &quot;Educative&quot;

# check reference count
print sys.getrefcount(some_var)

# create another refrence to someVar
another_var = some_var

# verify the incremented reference count
print sys.getrefcount(some_var)</code></pre>
</div>
<div class="code-wrapper">
<pre id="e0759c02-f4f5-450a-a368-8ff7669072a4" class="code"><code id="code">Output:
4
5</code></pre>
</div>
<p id="cb5bfd12-ba06-4462-8f73-49855c07837d" class="">
</p><p id="4f7a015c-b7bf-473b-a75c-b76409900510" class="">If you run the above snippet, you&#x27;ll see the reference count of the variable <code>some_var</code> increase. </p><p id="8e2ca7de-e1b7-4024-8560-c20aba4bb522" class="">When references to an object are removed, the reference count for an object is decremented. </p><p id="f7293d18-0bf0-494e-bbaf-f92cdd254009" class="">When the reference count becomes zero, the object is deallocated.</p><p id="846dde05-09f1-462e-8e44-071419633bd1" class=""><strong>The interpreter executes a single thread in order to ensure that the reference count for objects is safe from race conditions.</strong></p><p id="43fc0acc-0f2d-4cb5-981d-f743dd490417" class="">A reference count is associated with each object in a program.</p><p id="209b3271-f76f-471e-a1c2-9d9e12aaa1c5" class="">One possible solution could have been to associate one lock per object so that multiple threads could work on the object in a thread-safe manner. 
<strong>However, this approach would have resulted in too many locks being managed with the possibility of deadlocks.</strong></p><p id="7b9be8a9-f2fa-48da-9e59-ec40e02d83df" class=""><strong>Thus, a compromise was made to have a single lock that provides exclusive access to the Python interpreter.</strong></p><p id="1db50c04-bbc4-4ac8-9276-a599391a2aba" class="">This lock is known as the <strong>Global Interpreter Lock</strong>.</p><p id="aaa54b53-ebb0-4b12-a732-a61f0fa253de" class="">Execution of Python bytecode requires acquiring the GIL.</p><p id="5a0f5823-b712-4d50-ad21-d9e6d714798d" class="">This approach prevents deadlocks as there&#x27;s a single global lock to manage and introduces little overhead.</p><p id="ff5f96cc-e52e-4f04-89b6-a97abcd7bead" class=""><strong>However, the cost is paid by making CPU-bound tasks essentially single-threaded.</strong></p>
<div class="text-center">
    <img src="assets_env_image/13.png" class="rounded" alt="..." style="width: 80%;">
</div>
<p id="38ce1340-2a69-4025-88d7-d61d159d8396" class="">
</p><p id="8b8055e1-6227-405e-bd14-f45809fad8f8" class=""><strong>Removing GIL</strong></p><p id="b45c6c0b-4350-4e2c-ba7e-9db73754feb3" class="">One may wonder why the GIL can&#x27;t be removed from Python because of the limitations it imposes on CPU-bound programs.</p><p id="e22c867e-df6b-4559-b949-ba36faaaca85" class="">Attempts at removing GIL resulted in breaking C extensions and degrading the performance of single and multithreaded I/O bound programs.</p><p id="ace5048b-5f17-4e5e-9439-1edc047778dd" class="">Therefore, so far GIL hasn&#x27;t been removed from Python.</p><p id="01ed8675-5b78-433a-89f2-082af6721a07" class="">Python&#x27;s GIL is intended to serialize access to interpreter internals from different threads.</p><p id="69466199-b6a5-4ed4-9161-e0caa3c28ddf" class="">In summary, threads in Python are only good for blocking I/O.</p><p id="a286d661-7c78-492f-bbaa-42b3698a1e05" class="">While N threads are blocked on network or disk I/O or just waiting to reacquire the GIL, one thread runs in the Python interpreter.</p><p id="7123884c-547d-4804-a4c1-2c41f0f00b77" class="">In Python 3.7 the GIL is a boolean variable that is guarded by a mutex.</p><p id="e4df6cc5-5f2f-4b82-889b-bcb31dc99291" class="">The GIL implementation for Python 3.7 lives in the <a target="_blank" href="https://github.com/python/cpython/blob/3.7/Python/ceval_gil.h">ceval_gil.h</a> on Github.</p><p id="394626cd-c0cf-43d1-acdb-197dfdb02de9" class="">We reproduce the comments at the start of the file which explain the inner workings of the GIL.</p>
<div class="code-wrapper">
<pre id="e019e6a0-d392-4d7c-95ed-92a92b2027c9" class="code"><code id="code">/*
   Notes about the implementation:
   - The GIL is just a boolean variable (locked) whose access is protected
     by a mutex (gil_mutex), and whose changes are signalled by a condition
     variable (gil_cond). gil_mutex is taken for short periods of time,
     and therefore mostly uncontended.
   - In the GIL-holding thread, the main loop (PyEval_EvalFrameEx) must be
     able to release the GIL on demand by another thread. A volatile boolean
     variable (gil_drop_request) is used for that purpose, which is checked
     at every turn of the eval loop. That variable is set after a wait of
     `interval` microseconds on `gil_cond` has timed out.
      [Actually, another volatile boolean variable (eval_breaker) is used
       which ORs several conditions into one. Volatile booleans are
       sufficient as inter-thread signalling means since Python is run
       on cache-coherent architectures only.]
   - A thread wanting to take the GIL will first let pass a given amount of
     time (`interval` microseconds) before setting gil_drop_request. This
     encourages a defined switching period, but doesn&#x27;t enforce it since
     opcodes can take an arbitrary time to execute.
     The `interval` value is available for the user to read and modify
     using the Python API `sys.{get,set}switchinterval()`.
   - When a thread releases the GIL and gil_drop_request is set, that thread
     ensures that another GIL-awaiting thread gets scheduled.
     It does so by waiting on a condition variable (switch_cond) until
     the value of last_holder is changed to something else than its
     own thread state pointer, indicating that another thread was able to
     take the GIL.
     This is meant to prohibit the latency-adverse behaviour on multi-core
     machines where one thread would speculatively release the GIL, but still
     run and end up being the first to re-acquire it, making the &quot;timeslices&quot;
     much longer than expected.
     (Note: this mechanism is enabled with FORCE_SWITCHING above)
*/</code></pre>
</div>
<p id="9df5b625-99a7-44a4-8f98-157eb4dbcd97" class="">
</p><p id="cacad0e3-b9e5-4ac4-aa1d-94e20f021add" class=""><strong>Python Implementations without GIL</strong></p><ul id="9672fdd0-9556-4bbc-9ba1-3252054f772d" class="bulleted-list"><li>Jython (<a target="_blank" href="https://www.jython.org/">https://www.jython.org/</a>)</li></ul><ul id="6d49553f-1beb-46ca-ab14-3063d0bb5852" class="bulleted-list"><li>IronPython (<a target="_blank" href="https://ironpython.net/">https://ironpython.net/</a>)</li></ul><ul id="849db4a7-7ee0-4c3c-9ed4-840569cc73d5" class="bulleted-list"><li>pypy-stm (<a target="_blank" href="https://doc.pypy.org/en/latest/stm.html">https://doc.pypy.org/en/latest/stm.html</a>)</li></ul><p id="846e4049-e3ae-48ca-863e-32075cf79ccd" class="">
</p>